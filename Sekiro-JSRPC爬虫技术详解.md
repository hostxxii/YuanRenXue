# 爬虫与JS逆向基础概念解析

## 1. RPC 与 JSRPC 是什么？

* **RPC (Remote Procedure Call - 远程过程调用)**：
    * **概念**：允许一台计算机（客户端）像调用本地函数一样，去请求另一台远程计算机（服务器）上的服务或函数执行任务，并获取结果。
    * **类比**：打电话让你朋友在他电脑上帮你播电影，你只管看，不用管他怎么操作。
    * **核心**：实现分布式计算，让程序调用远程资源像调用本地资源一样简单。

* **JSRPC (JavaScript Remote Procedure Call)**：
    * **概念**：特指在 JavaScript 环境下，或常用于浏览器与服务器之间的 RPC。
    * **爬虫相关**：当网页通过 JS 异步加载数据（如点击“加载更多”）时，很可能就是 JSRPC。浏览器中的 JS 调用服务器上的接口获取数据，然后动态更新页面。
    * **挑战**：爬虫需要分析并模拟这些 JS 发起的请求来获取动态加载的数据。

## 2. Sekiro 项目介绍

* **是什么**：一个 RPC 框架，用于将难以从外部直接调用的功能（如特定设备环境、App内部、需要特定权限的功能）暴露出来，供其他程序（如爬虫）调用。
* **核心思想**：
    1.  **服务注册**：在有特殊能力的环境（如 App、特定浏览器环境）中运行 Sekiro Client，将能提供的服务（称为 `action`，属于某个 `group`）注册到 Sekiro Server。
    2.  **服务调用**：调用方（如爬虫）向 Sekiro Server 发起请求，指定要调用的 `group` 和 `action` 及参数。
    3.  **请求路由与执行**：Sekiro Server 将请求转发给对应的 Sekiro Client，Client 执行任务后将结果返回给 Server，Server 再返回给调用方。
* **用途**：解决 App 数据抓取、复杂 JS 动态参数计算、需要特定环境才能执行的操作等问题。

## 3. Sekiro 在浏览器 JS 环境下的执行步骤

1.  **启动 Sekiro Server**：作为中心调度服务器。
2.  **浏览器中植入并运行 Sekiro JS Client**（服务提供方）：
    * 加载 `sekiro-client.js`。
    * 创建 `SekiroClient` 实例，配置 Server 地址和 `group` 名称。
    * 定义并注册 `action` (JS 函数)，该函数接收请求参数 `request`，并通过 `resolve(data)` 返回结果或 `reject(error)` 返回错误。
    * 启动 Client，连接到 Server。
3.  **爬虫脚本发起调用**（服务调用方）：
    * 向 Sekiro Server 发送 HTTP 请求，URL 包含 `group` 和 `action`，以及其他参数。
4.  **Sekiro Server 转发请求**：根据 `group` 和 `action` 找到对应的浏览器 Client。
5.  **浏览器 JS Client 执行并响应**：执行注册的 `action` 函数，处理参数，返回结果。
6.  **Sekiro Server 返回结果给爬虫**。
7.  **爬虫脚本接收并处理结果**。

## 4. Sekiro 类 RPC 方式用于 JS 逆向的弊端与风险

### 弊端：

* **性能开销**：网络延迟和多次数据传输导致速度较慢。
* **架构复杂性**：需要部署和维护 Server 及多个 Client。
* **维护成本**：目标网站 JS 更新可能导致 Client 端 `Handler` 失效。
* **可扩展性限制**：高并发下 Server 和 Client 可能成为瓶颈。
* **非完全逆向**：只是执行 JS，未真正理解其逻辑。

### 被检测风险：

* **行为模式检测**：请求频率异常、缺少用户交互、固定调用模式。
* **环境检测**：WebDriver 特征、IP 质量、浏览器指纹不一致、Sekiro Client 脚本特征。
* **流量和负载异常**：少数 Client IP 承载大量请求。
* **针对性检测**：网站研究 Sekiro 特征进行反制。

### 不一定能实现：

* **JS 环境复杂性**：难以完美复现所有依赖。
* **反爬虫机制**：验证码、环境强校验等。
* **JS 代码本身限制**。

## 5. Sekiro Client 与油猴脚本及验证码

### 在油猴脚本中使用 Sekiro Client：

* **可行性**：可以。油猴脚本中引入 Sekiro Client JS，注册 `action`，使其成为服务提供方。
* **优点**：利用已登录会话，真实浏览器环境。
* **缺点/注意**：
    * **对应网页需一直打开**：脚本生命周期依赖页面 Tab。
    * 资源消耗。
    * 安全风险（确保 Server 和调用方可信）。
    * 可能影响用户体验。
    * 网站的 CSP 策略可能阻止。

### Sekiro Client 执行 JS 触发验证码的原因：

* **环境可疑**：自动化工具特征、IP 质量差、环境不一致。
* **执行的 JS 本身敏感**：或缺乏必要的用户行为上下文。
* **行为模式非人类**：调用频率过高、模式固定、页面加载不完整。
* **Sekiro Client 脚本被识别**。
    * 本质：Client 所处环境或行为让网站认为可疑。

### “一直开着网页”的理解 (油猴 vs. 控制台注入)：

* **油猴脚本**：是的，油猴脚本依附于打开的网页 Tab。Tab 关闭，Client 即失效。
* **控制台注入**：是的，同样依附于当前网页 Tab 的 JS 上下文。Tab 关闭，注入的 Client 也失效。
* **共同点**：只要 Client 在特定网页上下文中运行，该网页 Tab 就需保持打开。
* **区别**：油猴相对持久和自动化（匹配URL自动运行），控制台注入是临时的、手动的。
* **更稳定方案**：使用 Puppeteer、Playwright 等无头浏览器自动化框架在后台管理浏览器实例和 Client。

## 6. 无头浏览器与浏览器无痕模式

### 无头浏览器 (Headless Browser)：

* **定义**：没有图形用户界面 (GUI) 的浏览器。具备浏览器核心功能（解释HTML/CSS、执行JS、网络请求、渲染等），但在后台运行。
* **用途**：自动化测试、网页抓取 (Web Scraping)、生成截图/PDF、性能监控。
* **工具**：Puppeteer, Playwright, Selenium (配合驱动)。

### 浏览器无痕模式 (Incognito Mode / Private Browse)：

* **定义**：普通带界面浏览器的一种隐私浏览功能。
* **作用**：关闭无痕窗口后，不保存浏览历史、Cookie、网站数据、表单信息。
* **用途**：临时性隐私保护、测试网站“首次访问”体验、登录多账户。

### 关键区别：

| 特性         | 无头浏览器                               | 浏览器无痕模式                             |
| :----------- | :--------------------------------------- | :------------------------------------------- |
| **图形界面** | 无                                       | 有 (普通浏览器的一个特殊窗口模式)            |
| **核心目的** | 自动化操作、程序化控制                     | 临时性隐私保护，不留本地浏览痕迹             |
| **数据持久性** | 可被程序控制是否保存数据（默认也可能不保存） | 主要目的就是**不**在本地持久化浏览数据         |
| **使用方式** | 通过编程代码驱动                           | 用户在浏览器界面手动开启                     |
| **典型场景** | 自动化测试、网页爬虫、服务器端渲染         | 保护个人隐私浏览、测试网站新用户体验         |
| **是否可见** | 用户通常不可见（除非特意截图）               | 用户可见浏览器窗口和页面内容                 |

* **总结**：无头浏览器是给程序用的“苦力”，无痕模式是给用户戴的“临时面具”。